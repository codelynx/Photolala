// Auto-generated by credential-code
// DO NOT EDIT - This file will be overwritten

package com.electricwoods.photolala.utils

import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec

enum class CredentialKey {
    AWS_ACCESS_KEY_ID,
    AWS_DEFAULT_REGION,
    AWS_SECRET_ACCESS_KEY,
}

object Credentials {
    private data class EncryptedData(
        val data: ByteArray,
        val nonce: ByteArray,
        val tag: ByteArray
    )
    
    // Encrypted credential data as byte arrays
    private val encryptedData = mapOf(
        CredentialKey.AWS_ACCESS_KEY_ID to EncryptedData(
            data = byteArrayOf(
                -53, -31, -15, 0x41, 0x59, -69, 0x22, 0x6F,
                -77, 0x6D, 0x51, 0x46, -40, 0x4A, -100, 0x78,
                0x6E, -90, 0x44, -14
            ),
            nonce = byteArrayOf(
                -51, 0x6E, -81, 0x1A, -19, -1, 0x4A, -58,
                -94, -29, 0x66, 0x3E
            ),
            tag = byteArrayOf(
                0x17, -88, -112, -46, -57, 0x64, -33, -96,
                -1, -61, -66, 0x4C, -20, -71, 0x0F, -21
            )
        ),
        CredentialKey.AWS_DEFAULT_REGION to EncryptedData(
            data = byteArrayOf(
                0x18, 0x5E, -51, -104, -52, 0x1A, 0x25, 0x4F,
                -35
            ),
            nonce = byteArrayOf(
                -39, -124, -21, -68, -35, -12, -35, 0x32,
                -13, -62, 0x24, 0x79
            ),
            tag = byteArrayOf(
                -42, 0x46, -63, 0x3D, -15, -34, 0x16, -18,
                -73, 0x39, 0x79, 0x1B, 0x10, -63, -59, 0x47
            )
        ),
        CredentialKey.AWS_SECRET_ACCESS_KEY to EncryptedData(
            data = byteArrayOf(
                -85, -43, 0x1D, 0x52, -3, -102, 0x49, -63,
                0x09, -89, 0x42, -119, 0x74, 0x1F, 0x26, 0x7F,
                -52, -61, -62, -46, 0x1E, -103, 0x36, 0x69,
                -39, -45, -37, 0x3F, 0x49, 0x5F, 0x56, 0x1E,
                -109, 0x4F, -91, -59, -9, -25, 0x02, -65
            ),
            nonce = byteArrayOf(
                0x56, -124, -119, -27, 0x08, 0x15, 0x2C, -115,
                -25, 0x24, 0x63, -6
            ),
            tag = byteArrayOf(
                0x7A, -31, -80, -31, -69, 0x43, -57, 0x77,
                0x09, 0x6E, -2, 0x44, -96, 0x5A, 0x71, -28
            )
        ),
    )

    // Runtime decryption key (obfuscated)
    private val keyComponents = arrayOf(
        byteArrayOf(0x79, 0x4B, -124, 0x15),
        byteArrayOf(0x51, -85, 0x59, 0x3D),
        byteArrayOf(0x79, 0x4B, 0x03, -116),
        byteArrayOf(-115, -37, 0x5C, 0x11),
        byteArrayOf(-20, -108, -103, -46),
        byteArrayOf(-49, -100, 0x1E, -75),
        byteArrayOf(-39, 0x6F, -7, -5),
        byteArrayOf(-72, -33, -124, 0x53),
    )

    @JvmStatic
    fun decrypt(key: CredentialKey): String? {
        val encrypted = encryptedData[key] ?: return null
        
        return try {
            // Reconstruct the decryption key
            val keyData = keyComponents.flatMap { it.toList() }.toByteArray()
            val secretKey = SecretKeySpec(keyData, "AES")
            
            // Setup cipher for AES-GCM
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val gcmSpec = GCMParameterSpec(128, encrypted.nonce)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmSpec)
            
            // Combine ciphertext and tag for decryption
            val cipherTextWithTag = encrypted.data + encrypted.tag
            val decrypted = cipher.doFinal(cipherTextWithTag)
            
            String(decrypted, Charsets.UTF_8)
        } catch (e: Exception) {
            null
        }
    }
    
    // Optional: Decrypt with caching
    private val cache = mutableMapOf<CredentialKey, String>()
    
    @JvmStatic
    fun decryptCached(key: CredentialKey): String? {
        cache[key]?.let { return it }
        
        val decrypted = decrypt(key) ?: return null
        cache[key] = decrypted
        return decrypted
    }
    
    // Clear cache when needed
    @JvmStatic
    fun clearCache() {
        cache.clear()
    }
}